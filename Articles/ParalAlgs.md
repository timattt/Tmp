# Введение во что-то параллельное

Инклудим библиотеку:
```
#include "omp.h"
```

```
#pragma omp parallel
{
  ...
}
```
Это обозначает парал. участок кода, который будет исполняться несколькими потоками.
Все, что внутри будет выполнено несколькими исполнителями.

### Build

Нужен флаг **-fopenmp**.

Задание колличества потоков - в терминале написать **$set OMP_NUM_THREADS=5**. Потом запускать.


```
omp_get_num_threads()
```
 - возвращает кол. потоков.
Если возвращенное значение = 0, то это мастер поток. Можно определять номер потока как и в MPI.

### условия на переменные

* **shared** - переменная с именем из аргументов дикрективы будет разделенной памятью. Без shared переменные все равно будут shared.
* **private** - переменная будет уникальна для каждого потока. Значение до и после засирается.
* **firstprivate** - как private, только исходное значение переменной сохраняется.
* **lastprivate** - при выходе из региона значение сохранится. Будет запомнено последнее измененное.
* **if** - блок выполняется только, если условие из ифа истинно.
* **default** - все переменные по умолчанию будут такими, как мы зададим в этой директиве.

### директива for

```
#pragma omp for
  for (i = 0; i < 1000; i++)
```

Автоматически распределяет выполнение цикла между исполнителями.
Если исполнителей тут всего 4, то распределение будет такое:

* **thread 0** - i = (0, 249)
* **thread 1** - i = (250, 499)
* **thread 2** - i = (500, 749)
* **thread 3** - i = (750, 999)

### директива reduction (доп. условие к for)

Эта штука выполняет глобальные операции над переменными.
Синтаксис:

```
reduction(ОПЕРАТОР:ПЕРЕМЕННЫЕ)
```
Результат операции будет положен в первую переменную в списке.

### директива типа расписания schedule (доп. условие к for)

По умолчанию:
```
schedule(static, 1)
```

Используя тип **static** можно поставить размер блока, который приходится на один поток в цикле for.
```
schedule(static, 200)
```
Например такая дичь даст каждому потоку 200 итераций в цикле.

Используя тип **dynamic** последовательность блоков выдается сразу, как только поток закончилвыполнять блок цикла. А в режиме **static** все определено заранее.

Тип **guided** будет давать блоки размера больше параметра, который задан.

Тип **runtime** определяет все сам в процессе выполнения программы, причем можно задавать тип через переменную окружения **OMP_SCHEDULE**.

### Секции

```
#pragma omp parallel sections(nowait?)
{
#pragma omp section
{
printf("A");
}
#pragma omp section
{
printf("B");
}
}
```

Только одна секция.

```
#pragma omp single
  printf("C");
```

### Зависимость по данным

* Функции необходимо сделать независимыми от внешних данных, кроме как от значения параметров.
* В функции так же не должно быть статических переменных.
* Циклы, в которых есть выход по условию распараллеливать **нельзя**.

### Критическая секция

В ней есть доступ к данным, которые мы не хотим попортить.
В критическую секцию в один момент может зайти только один поток.
Все безыменные секция считаются одной большой.

```
#pragma omp critical (NAME)
{
...
}
```

### Барьерная синхронизация

```
#pragma omp barrier
```

### Атомарные операции

```
#pragma omp atomic
```

Гарантируется, что такая операция не прервется посередине.

### Порядок

```
#pragma omp ordered
```

Операции выполняются в порядке номеров потоков.

### Сброс

```
#pragma omp flush(var1, ...)
```

Сбрасывает немедленный сброс значений переменных в разделяемую память.
Таким образом гарантируется, что во всех потоках значение переменных одинаковое.

### одна приватная переменная для всех секций

Один раз объявили и во всех блоках для потока она будет.

```
#pragma omp threadprivate(var1, var2...)
```
