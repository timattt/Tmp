# Введение во что-то параллельное

Инклудим библиотеку:
```
#include "omp.h"
```

```
#pragma omp parallel
{
  ...
}
```
Это обозначает парал. участок кода, который будет исполняться несколькими потоками.
Все, что внутри будет выполнено несколькими исполнителями.

### Build

Нужен флаг **-fopenmp**.

Задание колличества потоков - в терминале написать **$set OMP_NUM_THREADS=5**. Потом запускать.


```
omp_get_num_threads()
```
 - возвращает кол. потоков.
Если возвращенное значение = 0, то это мастер поток. Можно определять номер потока как и в MPI.

### условия на переменные

* **shared** - переменная с именем из аргументов дикрективы будет разделенной памятью. Без shared переменные все равно будут shared.
* **private** - переменная будет уникальна для каждого потока. Значение до и после засирается.
* **firstprivate** - как private, только исходное значение переменной сохраняется.
* **lastprivate** - при выходе из региона значение сохранится. Будет запомнено последнее измененное.
* **if** - блок выполняется только, если условие из ифа истинно.
* **default** - все переменные по умолчанию будут такими, как мы зададим в этой директиве.

### директива for

```
#pragma omp for
  for (i = 0; i < 1000; i++)
```

Автоматически распределяет выполнение цикла между исполнителями.
Если исполнителей тут всего 4, то распределение будет такое:

* **thread 0** - i = (0, 249)
* **thread 1** - i = (250, 499)
* **thread 2** - i = (500, 749)
* **thread 3** - i = (750, 999)

### директива reduction (доп. условие к for)

Эта штука выполняет глобальные операции над переменными.
Синтаксис:

```
reduction(ОПЕРАТОР:ПЕРЕМЕННЫЕ)
```
Результат операции будет положен в первую переменную в списке.

### директива типа расписания schedule (доп. условие к for)

По умолчанию:
```
schedule(static, 1)
```

Используя тип **static** можно поставить размер блока, который приходится на один поток в цикле for.
```
schedule(static, 200)
```
Например такая дичь даст каждому потоку 200 итераций в цикле.

