# Семинар 7

## Многопоточка

### Потоки

*Простые операции с потоками*

* Простое создание потоков:

```java
Thread thread = new Thread(() -> {
    System.out.println("Hello from new thread " + Thread.currentThread().getName());
});
thread.start();
System.out.println("Hello from main thread " + Thread.currentThread().getName());
```

* Обработка ошибок, вылетающих из потока:

```java
thread.setUncaughtExceptionHandler((t, e) -> {
    e.printStackTrace();
});
```

* потоки-демоны - поток можно пометить демоническим - ВМ выключается, если все оставшиеся потоки - демоны

* ThreadGroup - каждый поток находится в группе, потоки из различных групп друг друга прерывать не могут. У класса ThreadGroup есть методы, которые позволяют получить список всех его нитей, а
также влиять/изменять их. Когда мы создаем новую нить, и явно не указываем группу, она присо-
единяется к той же группе, что и нить-создатель.

* ThreadLocal - позволяет хранить значения уникально для каждого потока. Фактически это map:
thread -> value. Нужно осторожно использовать с реактивным программированием, так как потоки
рандомно переключаются. Нужно очищать threadLocal при использовании с threadPool, иначе мусор
сохраняется

### Прерывание потоков

*Как правильно выключать потоки*

* Есть старые метод:

```java
thread.stop()
```

Его использовать не чаще всего не надо. Может быть ситуация, что поток залочил мьютекс. А потом поток убили - значит мьютекс останется залоченным.

* правильное решение - использовать:

```java
thread.interrupt()
```

* При прерывании потока в самом потоке вылетает InterruptedException, если в этот момент поток
ждал на методе, который такое исключение может кинуть
* После прерывания поток должен быстро завершиться
* Если произошло прерывание и нет возможности выкинуть InterruptedException, то флаг isInterrupted ставится в значение true- это полезно при livelock или прерывании
в вычислительных операциях
* При прерывании нужно либо установить статус прерванности, либо выбросить исключение

### JMM

* **Memory Ordering** - порядок взаимодействия с памятью (memory order) может отличаться от порядка
действий в коде (program order)
  * Процессор переупорядочеивает инструкции
  * Компилятор java тоже переупорядочивает инструкции. Причем всеми возможными способами (LoadStore, StoreStore, LoadLoad)
* **as-if-serial** гарантия - обещает, что переупорядоченные инструкции будут выполнены **одним пото-
ком**, так же, как если бы они выполнялись последовательно. С точки зрения памяти.
* Пример:

```java
a = 5;
b = 7;
int r1 = a; /* always 5 */
int r2 = b; /* always 7 */
```

Итоговый результат должен быть именно такой, но порядок инструкций может быть различным. Например, таким:

```java
a = 5;
int r1 = a; /* always 5 */
b = 7;
int r2 = b; /* always 7 */
```

* Cache Coherence гарантирует чтение актуальных значений из разных кешей, но пропагация записи
происходит не мгновенно, а с некоторой задержкой. Это происходит из-за наличия StoreBuffer в архитектуре процессора. Write-операция считается выполненной, когда она ушла из StoreBuffer в кеш - но из-за специфики строения StoreBuffer, это может произойти с задержкой, что являет собой дополнительное переупорядочивание.
* Таким образом - главная проблема - обеспечить нужный порядок для определенных операций. Вне зависимости от того, какие потоки эти операции выполняют.
* Для этого есть **happens-before**:
  * Пусть есть поток T1 и поток T2 (необязательно отличающийся от потока T1) и действия x и y, выполняющиеся в потоках T1 и T2 соответственно
  * Если x happens-before y, то треду T2 во время выполнения y и всех действий, идущих в порядке программы позже, будут видны все изменения, выполняемые тредом T1 в x и всех действиях, идущих в порядке программе ранее
* Список hb:
  * в ОДНОМ потоке действия объявленные программно раньше hb действий, которые объявлены программно позже
  * мониторный unlock hb мониторный lock на том же самом замке
  * запись в volatile hb последующего чтения оттуда
  * Thread.start hb любым действием в новом потоке
  * действие в потоке hb возвращения из join или isAlive = false
  * вызов прерывания другому потоку hb обнаружение прерывания
  * завершение конструктора hb начало финализатора
  * если A hb B и B hb C, то A hb C


